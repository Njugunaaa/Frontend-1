Summary / goal:
Add an Admin Dashboard and a full Flask backend to the existing React/Tailwind frontend repo (Frontend-1) so admin can CRUD Events & Sermons. Frontend UI must remain unchanged except for the new admin pages and the new public Sermons & Churches menu and the Upcoming / Past sections on the Events page. Backend must be in /backend, use SQLite, accept file uploads, generate minimal PDFs, and protect POST/PUT/DELETE by a single password header boltchurch@2025. The whole project must run in Replit and the frontend must talk to the backend via an environment-configurable API URL.

1 — Hard rules (do not deviate)

Do not change any existing pages/components other than adding new ones and small insertions where explicitly requested. Keep every existing asset path, CSS, class names, images, layout, fonts — unchanged.

Reuse existing UI components (cards, buttons, modals) for admin UI; if a new small wrapper is required, keep it minimal and isolated.

Timezone: Africa/Nairobi (use server-side date comparisons using +03:00 or pytz/Africa/Nairobi).

Admin password: boltchurch@2025 (used only in a custom header — see API auth).

Code must be clear, copy-paste ready.

2 — Repo changes to create

Create /backend folder in repo root with:

/backend
├── app.py
├── models.py
├── routes/
│   ├── events.py
│   └── sermons.py
├── utils/
│   └── pdf_generator.py
├── static/
│   └── uploads/        # store uploaded images
├── database.db         # SQLite
├── seed_data.py        # optional (create admin demo events/sermons)
└── requirements.txt


Add .env or Replit secrets for API_URL and any other env variable.

3 — Backend: design & implementation details
server basics

Use Flask + Flask-CORS + Flask-SQLAlchemy + Marshmallow (optional).

Run Flask on port 5000 by default. Enable CORS for the frontend origin (or * for dev).

Use database.db (SQLite) in /backend. Use SQLAlchemy models.

Models (SQLAlchemy)

Events

id: Integer primary key
title: String (required)
description: Text
image_path: String (relative path under /static/uploads)
date: Date (YYYY-MM-DD)
time: Time (nullable)
location: String (nullable)
category: String (nullable)
created_at: DateTime
updated_at: DateTime


Sermons

id: Integer primary key
title: String (required)
speaker_or_leader: String
date: Date
description: Text
media_url: String (YouTube)
created_at: DateTime
updated_at: DateTime

Status handling (upcoming/past)

Do NOT store status as a persisted column. Compute dynamically: if event.date >= today it’s upcoming; else past. Use server timezone Africa/Nairobi to compute today.

Authentication for modifying routes

Require header X-ADMIN-PASSWORD: boltchurch@2025 for POST / PUT / DELETE routes.

If missing or wrong, return 401 error JSON { "error": "unauthorized" }.

GET endpoints are public.

File uploads

Accept multipart POST/PUT for event images.

Allowed extensions: .jpg, .jpeg, .png. Max size: 8 MB (validate server-side).

Storage path: /backend/static/uploads/. Create if missing.

Use unique filenames: <timestamp>__<random6>__origfilename.ext (e.g., 20251120__a1b2c3__poster.png) to avoid overwrites. Return stored relative path in API response (/static/uploads/...).

Sanitize filenames.

PDF generation

Endpoint /api/events/pdf returns a minimal PDF (ReportLab recommended) showing two sections: Upcoming Events and Past Events. For each event show: title, date/time, location, short description, and image thumbnail path if possible. Provide appropriate Content-Type: application/pdf and Content-Disposition: attachment; filename="events_calendar.pdf".

API routes & contracts

Events

GET /api/events → returns all events (array)

GET /api/events/upcoming → returns array sorted asc by date (future + today)

GET /api/events/past → returns array sorted desc by date (most recent first)

POST /api/events (protected)

Accept multipart/form-data with fields:

title, description, date (YYYY-MM-DD), time (HH:MM, optional), location, category, image (file optional)

Response: 201 with created event JSON.

PUT /api/events/<id> (protected)

Accept JSON or multipart/form-data (if updating image)

Response: updated event JSON.

DELETE /api/events/<id> (protected)

Delete record and image file from disk if exists. Return 200 with { "success": true }.

GET /api/events/pdf → returns PDF file.

Sermons

GET /api/sermons → list sorted by date desc or asc (choose desc)

POST /api/sermons (protected)

Accept JSON { title, speaker_or_leader, date, description, media_url }

Respond 201 with sermon JSON

PUT /api/sermons/<id> (protected)

DELETE /api/sermons/<id> (protected)

Error format

Errors should be JSON: { "error": "message" } with proper HTTP status.

CORS & deployment readiness

Add Flask-CORS with allowed origins set to * for dev or https://<your-frontend-domain> for production. In Replit dev set *. Provide .env example FRONTEND_URL=http://localhost:3000.

4 — Frontend integration (React + existing repo)

High level: Do not rework existing components. Add admin pages and small public insertions only. Use React Router.

Where to add files (based on your structure)

You provided src/components and pages at repo root. Use this structure:

Add new pages under src/pages:

AdminLogin.jsx (route /admin)

AdminDashboard.jsx (route /admin/dashboard) — includes sidebar & router to EventsAdminPanel and SermonsAdminPanel

EventsAdminPanel.jsx (component in src/components/admin/) — CRUD UI for Events

SermonsAdminPanel.jsx — CRUD UI for Sermons

SermonsPage.jsx — public page for sermons (route /sermons or as new item under existing menu)

Modify Nav.jsx to add one menu item: Sermons & Churches linking to /sermons (churches is placeholder). Keep styling identical.

API base URL

Add .env variable for frontend: VITE_API_URL (since project uses Vite). Example .env:

VITE_API_URL=http://localhost:5000


Frontend fetch examples:

const API = import.meta.env.VITE_API_URL || "http://localhost:5000";

// sample GET
fetch(`${API}/api/events/upcoming`)
  .then(r => r.json())

// sample protected POST (using fetch + FormData for image)
fetch(`${API}/api/events`, {
  method: 'POST',
  headers: {
    'X-ADMIN-PASSWORD': 'boltchurch@2025'
  },
  body: formData
})


Admin auth & session

Admin login form locally validates the password field. On submit, call a small backend health-check or attempt to POST a no-op to verify header (or just store the password in localStorage keyed e.g. elim_admin_pw). Minimal approach:

On login success: localStorage.setItem('elim_admin_auth', '1') and localStorage.setItem('elim_admin_pw', 'boltchurch@2025') (or only store a token flag to avoid storing password if you prefer).

All admin fetches include header X-ADMIN-PASSWORD: <pwFromStorage>.

Reusing existing UI

Use existing modal component for Add/Edit forms. For new components, import and style using existing CSS classes.

Event cards on public Events page: after the existing calendar component(s) insert two new sections (exact markup sample below) and fetch from backend:

Upcoming Events (card list)

Past Events (card list)

On create/edit/delete, re-fetch events to update UI instantly. Optionally implement optimistic UI updates but re-fetch is fine.

Sermons page

New page SermonsPage.jsx fetches /api/sermons and displays responsive grid (3 columns desktop, 1 mobile) of cards. Each card contains:

Title

Speaker / Leader

Date (format DD MMM YYYY)

Short description

Embedded YouTube <iframe> with loading="lazy" preload="metadata" playsInline (add allowfullscreen). Use YouTube embed URL extractor from youtube link.

Delete confirmations

Use existing confirmation modal or implement window.confirm that matches existing style.

File URLs

The backend returns image_path as relative to backend root like /static/uploads/<filename>. For frontend, build image src as ${API}${image_path}.

5 — Replit-specific instructions (import, run both frontend & backend)

Importing

In Replit choose “Import from GitHub” and point to https://github.com/Njugunaaa/Frontend-1.

Running both servers on Replit

Replit allows a single “run” command but supports running both a frontend (Vite) and backend. Use a replit.nix or a combined Procfile or use a small start.sh that runs both in background with &.

Example start.sh (in repo root):

# start backend in port 5000
cd backend && FLASK_APP=app.py FLASK_ENV=development flask run --port=5000 &

# start vite frontend
cd .. # repo root
npm run dev


Make sure package.json has dev script vite and points to --host if needed. Replit web preview will then point to the frontend; API calls should go to http://localhost:5000.

Environment variables on Replit

Set VITE_API_URL to http://localhost:5000 in Replit secrets for dev.

If hosting backend separately later, update VITE_API_URL to that domain.

6 — Extra implementation details & sample code snippets
date check (server side)
from datetime import datetime
import pytz
tz = pytz.timezone('Africa/Nairobi')
today = datetime.now(tz).date()
# event.date is a date object
if event.date >= today: upcoming

secure file save sample (Flask)
def save_upload(file):
    if not allowed_file(file.filename):
        raise ValueError('bad ext')
    ts = datetime.utcnow().strftime("%Y%m%d%H%M%S")
    rand = secrets.token_hex(3)
    fname = secure_filename(file.filename)
    new = f"{ts}__{rand}__{fname}"
    path = os.path.join(app.root_path, 'static', 'uploads', new)
    file.save(path)
    return f"/static/uploads/{new}"

sample GET response shape (event)
{
  "id": 1,
  "title": "Sunday Service",
  "description": "Join us…",
  "image_path": "/static/uploads/20251120__a1b2c3__poster.png",
  "date": "2025-12-07",
  "time": "10:00",
  "location": "Main Hall",
  "category": "Service",
  "created_at": "2025-11-20T12:34:56",
  "updated_at": "2025-11-20T12:34:56"
}

7 — Seed & migrations

Provide seed_data.py to create initial few events/sermons so frontend shows something on first run. Use db.create_all() then add sample rows. Add python backend/seed_data.py instruction.

8 — QA checklist (what to verify locally on Replit)

 GET /api/events/upcoming returns correct upcoming events (use Africa/Nairobi)

 GET /api/events/past returns past events

 Add event via admin with image: image saved in /backend/static/uploads and event returned with image_path

 Edit event (with and without image) works

 Delete event removes DB row and file

 Add sermon via admin: appears immediately on /sermons

 YouTube iframe plays on mobile + desktop (use playsInline & loading="lazy")

 GET /api/events/pdf downloads a PDF containing Upcoming & Past sections

 Frontend run uses VITE_API_URL and points to backend

9 — Small nitty-gritty that matters (don’t skip)

Use X-ADMIN-PASSWORD header. Do not send password in URL or body.

For fetch with image, use FormData and omit Content-Type so browser sets it.

Ensure JSON endpoints respond with CORS.

Never alter existing component file names or their exported props — add new components that compose them.

Keep all new files in isolated folders (src/pages/admin, src/components/admin, /backend) to make PRs easy to review.

10 — Final deliverable instructions (what I expect Replit to create)

A working backend at /backend that implements all endpoints and constraints above.

New admin frontend pages/components placed under src/pages/admin or src/components/admin that reuse existing UI components.

Public pages updated: Nav.jsx includes Sermons & Churches menu; EventPage.jsx shows Upcoming and Past sections after existing calendars. SermonsPage.jsx added and wired.

.env example & Replit run instructions (start.sh) and seed_data.py.

A README section on how to run both frontend & backend in Replit (import from GitHub, set env var, run start script).